<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Illustrates:</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h3>Illustrates:</h3>

<pre><code class="r">library(loon)
</code></pre>

<ol>
<li>linked scatterplots</li>
<li>panning and zooming</li>
<li>creating new interactions through bindings</li>
</ol>

<h2>The data: Bone mineral density</h2>

<p>The data consists of measurements of spinal bone mineral density.  Several such measurements were  taken from 261 North American adolescents over a few years.  The entire dataset is called <code>bone</code> and can be found in the <code>R</code> package <code>ElemStatLearn</code>.</p>

<pre><code class="r">library(&quot;ElemStatLearn&quot;)
summary(bone)
</code></pre>

<p>As can be seen, there are four variates.  The <code>idnum</code> uniquely identifies each of the 261 adolescents (N.B. these are not numbered 1 to 261) and <code>gender</code> identifies their sex. The response variate of interest is <code>spnbmd</code> which is a ratio of the difference in bone mineral density as measured on two consecutive visits divided by their average. Similarly, the explanatory variate <code>age</code> is the average of the adolescent&#39;s age in years on those two visits. </p>

<p>In this vignette we investigate the fit of smoothing splines to this data.  </p>

<h2>The scatterplot</h2>

<p>To begin, execute the following code:</p>

<pre><code class="r"># The plot
x &lt;- bone$age
y &lt;- bone$spnbmd
#  A scatterplot
p &lt;- l_plot(x, y,
            color=&quot;darkgrey&quot;,
            xlabel=&quot;age&quot;, ylabel=&quot;spnbmd&quot;,
            showGuides = TRUE, showScales = TRUE,
            itemLabel = paste0(&quot;IDnum = &quot;, bone$idnum, &quot;\n&quot;, 
                               bone$gender, &quot;\n&quot;, 
                               &quot;Age: &quot;, bone$age),
            showItemLabels = TRUE,
            linkingGroup=&quot;Bone density&quot;,
            title = &quot;Spinal bone mineral density (spnbmd)&quot;)
</code></pre>

<p>Two windows will have appeared once the above code has been executed.  One is the plot <code>p</code>, the other the <strong>inspector</strong> of the plot <code>p</code>. </p>

<p>The plot is interactive.  Hovering the mouse over a point in the plot, for example, will pop up the <code>itemLabel</code> for that point.  Scrolling on mouse wheel (or equivalent) over the plot <strong>zooms</strong> in (or out) on the plot; note that the zoom is centred at the mouse position.  For <strong>horizontal zooming</strong> only, hold the &ldquo;control&rdquo; key down while scrolling;  for <strong>vertical zooming</strong> only hold the &ldquo;alt&rdquo; (or <code>cmd</code> on a Mac) key while scrolling.</p>

<p>Zoom in anywhere on the plot.  Notice that the <strong>inspector</strong> displays a miniature version of the whole plot as its <strong>World View</strong> at the top of its display.  The plot is bounded in the World View by a grey rectangle and the region of the plot that is displayed is shown as a brighter region bounded by a black rectangle.  This bright display region can be grabbed by clicking (and holding depressed) the left (or primary) mouse button.  Moving the mouse around while keeping the left button depressed moves the bright region in the inspector which in turn cause the display in the plot to update accordingly.  In this way, the inspector World View can be used to <strong>pan</strong> the entire display.  Alternatively, <strong>panning</strong> may also be effected by right (or secondary) button clicking on the interior of the plot, holding that mouse button down and moving the mouse.  In the inspector the region moves with the mouse, in the plot the background does.</p>

<p>Panning and zooming can occur either on the inspector plot or on the plot itself.  In either case, the panning or zooming is constrained to the horizontal when the control key is held at the same time and to the verticle when the <code>alt</code> or <code>cmd</code> key is held.</p>

<p>To get the displayed scatterplot back to its original scale, in the inspector click on <code>scale to: plot</code>.  Alternatively the same effect can be hand programmatically as
<code>l_scaleto_plot(p)</code>.  (To scale to all layers in the plot use <code>l_scaleto_world(p)</code>.)</p>

<p>See <code>help(l_plot)</code> for more details and examples.</p>

<p>In the inspector window, immediately below the World View there are several <strong>tabs</strong>, the first of which is the <strong>Analysis tab</strong>.  The first subsection of the analysis tab contains plot attributes.  The values here were determined when the plot <code>p</code> was created according to the values of the arguments given to <code>l_plot(...)</code>.  These can be changed in the inspector by toggling the check boxes.</p>

<p>The complete set of arguments that could have been used at the time of creation can be had by querying the plot <code>p</code> as <code>names(l_info_states)</code>.  The values can also be accessed and changed programmatically for axample as in</p>

<pre><code class="r">p[&quot;showItemLabels&quot;]
p[&quot;showGuides&quot;]
p[&quot;swapAxes&quot;] &lt;- TRUE
p[&quot;swapAxes&quot;] &lt;- FALSE
</code></pre>

<p>The vertical variate, <code>spnbmd</code>, measured the  <em>change</em> in spinal bone mineral density.  Anything above zero indicates an increase, anything below a decrease; the magnitude is the rate of change in density.  It might be of interest, then, to add a horizontal line to the plot at zero.  This is accomplished by <strong>layering a line</strong> on the plot <code>p</code> as follows:</p>

<pre><code class="r">axis &lt;- l_layer_line(p,
                     x=extendrange(x, f=0.5), y=c(0,0),
                     label=&quot;axis&quot;, linewidth=2,
                     color = &quot;black&quot;,
                     dash=c(10,10),
                     index=&quot;end&quot;)   # last argument places axis behind other layers
</code></pre>

<p>This &ldquo;axis&rdquo; can be turned on and off via the inspector or programmatically.  On the inspector, click on the <strong>Layers</strong> tab.  The layers appear in a list ordered from top to bottom in the inspector in the order in which they are displayed in the plot.  The <code>axis</code> appears below the Scatterplot and hence is dispayed behind the points. </p>

<p>Selecting the axis, the up and down buttons at the bottom of the list allow the axis to be placed above or below the Scatterplot.  The axis (or Scatterplot) can be moved up or down in the display.  Either can be made (temporarily) invisible by clicking on the icon showing a cartoon eye with a stroke through it and made visible again by clicking on the cartoon eye.  Try it.</p>

<p>The axis (or any other layer, e.g. the Scatterplot), could be removed entirely with the minus sign.  Don&#39;t do this right now; click on the &ldquo;Analysis&rdquo; tab instead.</p>

<h2>Histogram</h2>

<p>A histogram can be constructed in the same way for <em>numeric</em> values.  Even so, one can be used to construct a simple barplot for the factor <code>gender</code>:</p>

<pre><code class="r">h &lt;- l_hist(as.numeric(bone$gender), # note as.numeric(...)
            binwidth = 1, showBinHandle = FALSE,
            showStackedColors = TRUE,
            xlabel = &quot;gender&quot;,
            linkingGroup=&quot;Bone density&quot;,
            title = &quot;Gender (female=1; male=2)&quot;
            )
</code></pre>

<p>Note that the inspector now shows the histogram in the World View and that the plot section of the Analysis now has options peculiar to a histogram.</p>

<p>The histogram and the scatterplot both have the same <code>linkingGroup</code> &ldquo;Bone density&rdquo; and the inspector shows that the 2 plots are <strong>linked</strong>.  Selecting the left most bar of the histogram highlights all of the females in both plots.  Switching back and forth between the two bars while observing the scatterplot shows that the pattern for males seems to be shifted slightly to the right of those for the females.</p>

<p>Similarly,  selecting any point in the scatterplot causes a corresponding slice of the bar in which it appears in the histogram to be highlighted.  </p>

<p><strong>Multiple selections</strong> can made by holding the <strong>shift key</strong> while selecting.  Alternatively, clicking on the background, holding the mouse button down while <strong>sweeping</strong>  out a rectangle will highlight all data objects which intersect with the rectangle.</p>

<p>Once selected, the display of the points can be <strong>modified</strong> by clicking on any of the colour patches to change their colour, or the glyph symbols to change the shape of points, the <code>-</code> and <code>+</code> signs to change size, and the <code>deactivate</code> (and <code>reactivate</code>) to remove the points from (or return them to) the display. </p>

<p>Try selecting the points in the scatterplot and making various modifications.  Note that because the displays are linked the changes are effected (where sensible) in both displays.  Note that once the points have been coloured it is also possible to select points by colour from the inspector.</p>

<p>Note that with <strong>shift sweeping</strong> (sweeping while the shift key pressed), multiple selections can be made.  Couple this with <code>dynamic</code> selection that <code>deselect</code>s or <code>invert</code>s and very complex patterns of selected points can be constructed.</p>

<p>To return the displays to their original configuration, from the inspector reactivate all of the points, then select <code>all</code> from the <code>Select</code> part of the <code>Analysis</code> panel, then select the filled circle glyph shape, and a single colour from those available (selecting the colour <code>+</code> will pop up a colour picker).  To return to the original colour execute <code>p[&quot;color&quot;] &lt;- &quot;darkgrey&quot;</code>.</p>

<h2>Panning and brushing</h2>

<p>A second scatterplot could display other variates.  For example, plotting the age versus the patient ID number gives:</p>

<pre><code class="r">p2 &lt;- l_plot(bone$idnum, bone$age,
             xlabel=&quot;idnum&quot;, ylabel=&quot;age&quot;,
             linkingGroup=&quot;Bone density&quot;,
             title = &quot;ID numbers and age&quot;)
</code></pre>

<p>Ideally this plot would look like fairly uniform scatter.  Assuming that <code>idnum</code> was assigned with recruitment there are some patterns.  In the middle of the <code>idnum</code> range, for example, there appears to be a preponderance of older ages followed immediately by a preponderance of younger ages. </p>

<p>We might investigate how the change in <code>idnum</code> from low to high manifests itself in the relationship between bone mineral density and age by <strong>brushing</strong> the points in <code>p2</code> and observing the effect in <code>p</code>.  To do this, click on <code>p2</code> so that the inspector has <code>p2</code> as its focus (appears in the inspector World View). In the inspector <code>Select</code> panel (on the <code>Analysis</code> tab) select <code>by: brushing</code>.  A rectangle will appear in <code>p2</code>; this is the <strong>brush</strong>.  </p>

<p>Since we are interested in observing the relationship between bone density and age <strong>conditional</strong> on <code>idnum</code>, we need to shape the brush to be a long, relatively thin, vertical brush.  The brush is reshaped by selecting the box in its lower-right corner and moving it until you get the shape desired.  The brush will maintain that shape (unique to <code>p2</code>) until it is again changed.</p>

<p>Now clicking anywhere in <code>p2</code> will have the brush follow the mouse (while the mouse button is depressed) and highlight all points located within the rectangle.  For example beginning at the lower left corner of the scatterplot and moving the mouse left to right horizontally, a tall narrow brush should select points with the same (or nearly the same) <code>idnum</code> and the relationship between bone density and age as the <code>idnum</code> increases can be seen in the original scatterplot <code>p</code>.  </p>

<p>To have a <strong>sticky brush</strong>, or have the brush accumulate the selections brushed, simply use the shift key as before.  Again the nature of the brushing can be changed by selecting different <code>dynamic</code> modes.  To <strong>turn off brushing</strong> select <code>sweeping</code> in the <code>Select</code> panel of the inspector for <code>p2</code>.</p>

<p><strong>Zooming</strong> and <strong>panning</strong> in <code>p2</code> also reveals some interesting structure.  Horizontally zoom on <code>p2</code> until each <code>idnum</code> is well separated. Then horizontally pan across the <code>idnum</code>s (most easily done from the inspector World View). </p>

<p>It becomes easy to see that each subject (<code>idnum</code>) appears one, two, or three times.  Because each value is the <em>change</em> in bone density (and so must be calculated on the basis of two visits) this means that each person had two, three, or four visits.  Checking the <code>scales</code> and <code>guides</code> boxes of the plot panel in the inspector and panning reveals also that for every <code>idnum</code>, the difference in <code>age</code> are is at most 2 and does not appear to span more than 3 years.  Together, this suggests that the data may have been collected in a single time period of about 3 years.  Moreover, the bulk of those <code>idnums</code> which have three entries occur early in the order of <code>idnum</code>, possibly meaning early in the recruitment.</p>

<h2>Adding a (dynamically changing) smooth</h2>

<p>To summarize the relationship, a smooth curve could be added to any scatterplot.  Here, we will add a smoothing spline fitted to bone mineral density as a function of time (i.e. to the data of <code>p</code>).</p>

<pre><code class="r">library(splines)
# Fit a smoothing spline
fitsmooth &lt;- smooth.spline(x, y, df=5)
xOrder &lt;- order(x)
smooth &lt;- l_layer_line(p,
                       x=x[xOrder],
                       y=predict(fitsmooth,x=x[xOrder])$y,
                       label=&quot;smooth fit&quot;, linewidth=4,
                       color = &quot;blue&quot;)
</code></pre>

<p>The smooth shows that the change in spinal bone mineral density rises up to about 12 years of age and then declines thereafter ultimately hitting zero.</p>

<p>Of course this is the aggregate behaviour, over both sexes.  It might be interesting to see how this changes for males and for females.  We could do this by adding a smooth for each sex but there may be other subgroups of the data that we would like to investigate.  To that end we introduce a <strong>dynamic update</strong> to the smooth.</p>

<pre><code class="r">## Define the update function
updateSmooth &lt;- function(myPlot, minpts, df, color=&quot;blue&quot;) {
  ## Get the values for x and y from the plot
  ##
  ## For x
  xnew &lt;- myPlot[&#39;xTemp&#39;]
  if (length(xnew) == 0) {xnew &lt;- myPlot[&#39;x&#39;]}

  ## For y
  ynew &lt;- myPlot[&#39;yTemp&#39;]
  if (length(ynew) == 0) {ynew &lt;- myPlot[&#39;y&#39;]}

  ## Now **only** use the active selected points to construct the smooth
  sel &lt;- myPlot[&#39;selected&#39;] &amp; myPlot[&#39;active&#39;]
  xnew &lt;- xnew[sel]
  ynew &lt;- ynew[sel]
  Nsel &lt;- sum(sel)

  if (Nsel &gt; 3 &amp; diff(range(xnew)) &gt; 0) {
    ## Find the range of the selected x values
    xrng &lt;- extendrange(xnew)
    xvals.temp &lt;- seq(from=min(xrng),
                      to=max(xrng), 
                      length.out=100)

    ## Redo our smooth **only** if we have enough points
    if ((Nsel &gt; minpts) &amp; (minpts &gt; (df + 1))){
      fit.temp &lt;- smooth.spline(xnew, ynew, df=df)
      ypred.temp &lt;- predict(fit.temp,x=xvals.temp)$y
      ## update the smooth
      if (smooth %in% l_layer_ids(myPlot)) {
        ## reconfigure the smooth with new data
        l_configure(smooth, x=xvals.temp, y=ypred.temp)
      } else {
        ## If the smooth has been deleted, then we recreate it 
        ## (N.B. in the global environment)
        smooth &lt;&lt;-  l_layer_line(myPlot,
                                 x=xvals.temp, 
                                 y=ypred.temp,
                                 label=&quot;smooth fit&quot;, 
                                 linewidth=4,
                                 color = color)
      } 
    }
  }
  ## Update the tcl language&#39;s event handler
  tcl(&#39;update&#39;, &#39;idletasks&#39;)
}
</code></pre>

<p>Now, we would like to have this update called whenever any interesting change in state occurs.  There are numerous such possible states (see <code>names(l_info_states(p))</code> or <code>l_help(&quot;learn_R_bind&quot;)</code> ).  Here we bind an anonymous function of no arguments to be called whenever there is any change in the values of <code>p</code> contained in its <code>selected</code> state.  This means that the function is called if any point in <code>p</code> is selected or deselected.  </p>

<p>Note also that the smooth is based on the <strong>temporary</strong> <code>x</code> and <code>y</code> values. Points in a <strong>scatterplot may be moved</strong> by selecting them with the control button depressed (as well as shift for multiple selection).  Alternatively, <strong>selected points may be pushed together, distributed vertically or horizontally, arranged on a grid, or jittered</strong> by selecting the corresponding <code>move</code> button from the <code>Modify</code> panel of the inspector.  **All points can be returned to their original position by</p>

<pre><code class="r"># Here we &quot;bind&quot; the anonymous to the named state changes of p
l_bind_state(p, c(&quot;selected&quot;),
             function() {updateSmooth(p, 10, 5, &quot;blue&quot;)}
)
</code></pre>

<p>Now go to the histogram and select first the female bar, then the make bar, and watch how the smoothing spline adapts to the sex.  Clearly, females have greater changes in spinal bone mineral density at a younger age than do males.  No doubt this is a consequence of the different ages at which girls and boys sexually mature.</p>

<p>Brushing any set of points, from any of the linked plots will now cause the smooth function to automatically recalculate and redisplay.  In this way one might pursue, for example how the smooth changes over subsets of <code>idnum</code> values.</p>

<p>Note that the points must be both active and selected.  We could, for example,  focus on how the smooth changes <em>only for any subset of females</em> by first deactivating all males and then brushing the subset of the females.</p>

<p>Note that the states that are bound can be seen as <code>l_bind_state_ids(p)</code> and deleted using <code>l_bind_state_delete(p, &quot;stateBinding0&quot;)</code>.</p>

<h2>A smooth as a running linear fit</h2>

<p>Linear smoothers can be thought of as the connected predicted values of locally fitted linear models having weights which are maximal at the point \(x\) where the prediction is being made and which drop off to zero for \(x\) values far away from it.</p>

<p>To illustrate this we add a straight line to the scatterplot that is fitted to the data via weighted least squares using Gaussian weights.  For any collection of \(x\) values, the prediction will be made at their median.</p>

<p>The Gaussian weight function will be centred at the median:</p>

<pre><code class="r">GaussWt &lt;- function(x) {
  # Get an estimated standard deviation
  h &lt;- diff(range(x))/4
  # Centre at median
  xloc &lt;- median(x)
  # Gaussian density
  dnorm(x, mean=xloc, sd=h)
}
</code></pre>

<p>Use these weights to fit a line to the data.</p>

<pre><code class="r"># Fit a local line using some Gaussian weights.
# Prediction will be at the median of x, fit by
### weights that decrease with x&#39;s
# distance from the median.
fitwls &lt;- lm(y ~ x, weights=GaussWt(x))
linewls &lt;- l_layer_line(p, 
                        x=x,
                        y=predict(fitwls,
                                  newdata=data.frame(x=x)),
                        label=&quot;Fitted line&quot;,
                        linewidth=4,
                        color = &quot;blue&quot;)
</code></pre>

<p>Clicking on the <code>Layers</code> tab in the inspector shows the scatterplot, the axis, the smooth fit, and the Gaussian weight straight line.  Select the last of these and render it invisible by clicking on that button, or, by programmatically by executing the following.</p>

<pre><code class="r">l_layer_hide(p, smooth)
</code></pre>

<p>Now make the fitted line update to fit only the selected points.</p>

<pre><code class="r">updateLocalLine &lt;- function(myPlot, minpts, df, volor=&quot;blue&quot;) {
  ## Get the values for x and y from the plot
  ## For x
  xnew &lt;- myPlot[&#39;xTemp&#39;]
  if (length(xnew) == 0) {xnew &lt;- myPlot[&#39;x&#39;]}

  ## For y
  ynew &lt;- myPlot[&#39;yTemp&#39;]
  if (length(ynew) == 0) {ynew &lt;- myPlot[&#39;y&#39;]}

  ## Now **only** use the active selected points to construct the smooth
  sel &lt;- myPlot[&#39;selected&#39;] &amp; myPlot[&#39;active&#39;]
  xnew &lt;- xnew[sel]
  ynew &lt;- ynew[sel]
  Nsel &lt;- sum(sel)
  if (Nsel &gt; 3 &amp; diff(range(xnew)) &gt; 0) {
    xrng &lt;- extendrange(xnew)
    xvals.temp &lt;- seq(from=min(xrng),
                      to=max(xrng), 
                      length.out=100)
    ## Redo line if more than two points.
    if (Nsel&gt; 2) {
      fit.wls &lt;-  lm(ynew ~ xnew, weights=GaussWt(xnew))
      ywls.temp &lt;- predict(fit.wls,
                           newdata=data.frame(xnew=xvals.temp))
      ## update the fit
      if (linewls %in% l_layer_ids(myPlot)) {
        l_configure(linewls, x=xvals.temp, y=ywls.temp)
      } else {
        ## If it&#39;s been deleted, we recreate it (in the global environment).
        linewls &lt;&lt;- l_layer_line(myPlot,
                                 x=xvals.temp,
                                 y=predict(fitwls,
                                           newdata=data.frame(x=xvals.temp)
                                 ),
                                 label=&quot;GaussWt at median line&quot;, 
                                 linewidth=4,
                                 color=&quot;blue&quot;
        )
      }
    }

  }
  ## Update the tcl language&#39;s event handler
  tcl(&#39;update&#39;, &#39;idletasks&#39;)
}
</code></pre>

<p>And now bind this update function to change in <code>p</code> of  either the <code>select</code> or the <code>active</code> states.  </p>

<pre><code class="r"># Here we &quot;bind&quot; the anonymous to the named state changes of p
l_bind_state(p, c(&quot;active&quot;,&quot;selected&quot;),
             function() {updateLocalLine(p, 10, 5, &quot;blue&quot;)}
)
</code></pre>

<p>Selecting the male or female sex in the histograms will show the weighted least squares line for that sex.  Brushing a tall thin vertical brush on <code>p2</code> will show how the fitted line changes (or not) as the similar <code>idnum</code>s change.  But most interestingly, and the object of this lesson, is to brush <code>p2</code> with a short very wide brush so that the <code>age</code> can be kept roughly constant.  As <code>age</code> increases or decreases, the line segment changes its fit: both in height and in slope.  The smooth seen earlier is essentially the connected midpoints of these line segments.</p>

</body>

</html>
